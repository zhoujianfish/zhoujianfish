[{"title":"Javascript定时器中的this指向","date":"2017-04-11T06:06:34.597Z","path":"2017/04/11/Javascript定时器中的this指向/","text":"使用js中的定时器（setInterval，setTimeout），很容易会遇到this指向的问题。直接上例子：var name = &apos;my name is window&apos;; var obj = { name: &apos;my name is obj&apos;, fn: function () { var timer = null; clearInterval(timer); timer = setInterval(function () { console.log(this.name); //my name is window }, 1000) } } 在这里，从this.name可以看出this的指向是window。 如果没有特殊指向，setInterval和setTimeout的回调函数中this的指向都是window。这是因为JS的定时器方法是定义在window下的。但是平时很多场景下，都需要修改this的指向。这里总结了几种：1、最常用的方法：在外部函数中将this存为一个变量，回调函数中使用该变量，而不是直接使用this。 var name = &apos;my name is window&apos;; var obj = { name: &apos;my name is obj&apos;, fn: function () { var that = this; var timer = null; clearInterval(timer); timer = setInterval(function () { console.log(that.name); //my name is obj }, 1000) } } 在fn中加了var that = this; 回调函数中使用that代替this即可。这种方法最常见，使用也最广泛。 2、使用bind()方法（bind()为ES5的标准，低版本IE下有兼容问题，可以引入es5-shim.js解决）bind()的作用类似call和apply，都是修改this指向。但是call和apply是修改this指向后函数会立即执行，而bind则是返回一个新的函数，它会创建一个与原来函数主体相同的新函数，新函数中的this指向传入的对象。 var name = &apos;my name is window&apos;; var obj = { name: &apos;my name is obj&apos;, fn: function () { var timer = null; clearInterval(timer); timer = setInterval(function () { console.log(this.name); //my name is obj }.bind(this), 1000) } } 在这里为什么不能用call和apply，是因为call和apply不是返回函数，而是立即执行函数，那么，就失去了定时器的作用。 3、使用es6的箭头函数：箭头函数的最大作用就是this指向。var name = &apos;my name is window&apos;; var obj = { name: &apos;my name is obj&apos;, fn: function () { var timer = null; clearInterval(timer); timer = setInterval(() =&gt; { console.log(this.name); //my name is obj }, 1000) } } 箭头函数没有自己的this，它的this继承自外部函数的作用域。所以，在该例中，定时器回调函数中的this，是继承了fn的this。当然箭头函数也有兼容问题，要是兼容低版本ie，需要使用babel编译，并且引入es5-shim.js才可以。","tags":[]},{"title":"DSS","date":"2017-04-09T15:01:33.000Z","path":"2017/04/09/DSS/","text":"fgfdgdfgfdgdfgfdgfdgfdg","tags":[{"name":"sd","slug":"sd","permalink":"https://zhoujianfish.github.io/tags/sd/"}]},{"title":"","date":"2017-03-20T10:06:51.802Z","path":"2017/03/20/js基础/","text":"####一.数组的认识 数组的定义:用来存储表示一堆变量的集合 数组的特点:1.数组是有序号的,从0开始 2.数组中的存储的变量类型可以是不同的类型 数组访问;数组可以通过数组名称[序号值]来访问,例如: arr[1]访问数组中的第二个元素 数组的长度的获取.数组名称.length 数组的循环,通过for循环,形式是:for(var i = 0;i &lt; 数组的长度; i ++){执行代码} 数组的基本应用;设置不同的行现实不同的颜色,设置全选不选以及反选；实现九宫格算法 拍他思想的认识:1.先设置所有的为一种属性2.然后设置自己的独立属性,覆盖原来的 this的认识:this一般在事件指令中,表示谁被触发了,就表示谁 拍他思想的应用,以及设置不同颜色的方法的认识 变量和属性以及方法和函数的区别:属性需要隶属于某一个对象,变量不需要,函数属于某一个对象就是方法 属性的扩展：可以给某个一个对象扩展属性，用来记录销毁中的值 tab栏切换 tab栏切换抽取 数组的基本方法:1-push(),在数组的后面添加一个元素返回数组的长度;2-pop():从数组的后面删除一个元素返回删除的元素;3-shift(),从数组的前面删除一个元素 ,4-unshift(),从数组的前面添加一个元素,5-contact连接两个元素,原来的数组不会发生改变,6.sort();数组转化成字符后排序,但是如果要按照数值排序,需要使用函数参数,函数参数会自动执行7.数组转化字符：join（）8.字符转化数组 ：split（） ####二.字符串的常用方法的认识 转化成字符方法的认识 1.使用连接符号+ 2.使用String方法 获取某一位置的字符以及unicode编码的认识: charCodeAt()；获取某一个位置的字符：charat(); 获取某一个字符的位置的方法的认识,indexof(),如果从后往前后去：lastindexof(),注意排序还是从左到右 获取一个字符的真正的占字节的方法的获取:一般如果是汉字那么他的unicode编码就是大于127,在0和127内是普通的字母数字。 转化大小写：转化大写：toUpperCase;转化小写：toLowerCase获取某一个字符串的位置{% codeblock lang:JavaScript %} var charString = 'my is abc dcf a'; var poiont = charString.indexOf('n'); console.log(poiont); // -1; {% endcodeblock %} indexOf:会获取传入的字符的位置,位置从左到右边,如果获取到第一个元素后,就会返回第一个获取元素的位置,如果没有对应的元素就会返回 -1; {% codeblock lang:JavaScript %} var charString = 'my is abc dcf a'; var newPoint = charString.lastIndexOf('a'); console.log(newPoint); {% endcodeblock %} lastIndexOf:从后往前找对应的元素,如果找到就会把对应的位置返回,但是注意位置排序还是从左到右顺序数;","tags":[]},{"title":"","date":"2017-03-18T11:44:45.077Z","path":"2017/03/18/Ajax/","text":"Ajax注意点:PHP是服务端开发语言,所以不能直接运行,需要在服务骑上运行 如何在服务器上运行: 将编写好的代码文件夹放到服务器对应的文件夹下 然后通过浏览器访问服务器对应的文件 然后通过浏览器选择需要执行的那个php文件 PHP中也有数组$arr = array(1,3,5); echo $arr[1]; print_r($arr); JS中有数组和字典var arr = [1, 3, 5]; var dict = {&quot;name&quot;:&quot;nj&quot;, &quot;age&quot;:&quot;18&quot;} PHP中也有数组和字典$arr = array(1, 3, 5); $dict = array(&quot;name&quot;=&gt;&quot;nj&quot;, &quot;age&quot;=&gt;&quot;18&quot;); 在PHP中要输出数组/字典需要使用print_r###遍历 $arr = array(1, 3, 5, 7, 9); for($i = 0; $i &lt; count($arr); $i++){ echo $arr[$i]; echo ““; } $arr = array(1, 3, 5, 7, 9); $index = 0; while ($index &lt; count($arr)){ echo $arr[$index]; echo &quot;&lt;br&gt;&quot;; $index++; } $arr = array(1, 3, 5, 7, 9); $dict = array(&quot;name&quot;=&gt;&quot;nj&quot;, &quot;age&quot;=&gt;&quot;18&quot;); foreach ($dict as $item) { echo $item; echo &quot;&lt;br&gt;&quot;; }","tags":[]},{"title":"Javascript的this用法","date":"2017-03-14T15:31:24.565Z","path":"2017/03/14/JavaScript/","text":"this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。比如，123function test()&#123; this.x = 1 &#125; 随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。下面分四种情况，详细讨论this的用法。情况一：纯粹的函数调用这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global。请看下面这段代码，它的运行结果是112345function test()&#123; this.x = 1; alert(this.x); &#125;test(); // 1 为了证明this就是全局对象，我对代码做一些改变：12345 var x = 1;function test()&#123; alert(this.x); &#125;test(); // 1 ### 运行结果还是1。再变一下：123456var x = 1;function test()&#123; this.x = 0; &#125;test();alert(x); //0 情况二：作为对象方法的调用函数还可以作为某个对象的方法调用，这时this就指这个上级对象。1234567function test()&#123; alert(this.x); &#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m(); // 1 情况三 作为构造函数调用所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。12345function test()&#123; this.x = 1; &#125;var o = new test();alert(o.x); // 1 运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变：123456var x = 2;function test()&#123; this.x = 1; &#125; var o = new test(); alert(x); //2 运行结果为2，表明全局变量x的值根本没变。情况四 apply调用apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。12345678 var x = 0;function test()&#123; alert(this.x); &#125;var o=&#123;&#125;;o.x = 1;o.m = test;o.m.apply(); //0 apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。如果把最后一行代码修改为12o.m.apply(o); //1 运行结果就变成了1，证明了这时this代表的是对象o。","tags":[]}]