[{"title":"ig file instead of using _config.yml","date":"2017-05-23T16:00:50.000Z","path":"2017/05/24/ig-file-instead-of-using-config-yml/","text":"","tags":[]},{"title":"jQuery","date":"2017-05-19T15:56:47.000Z","path":"2017/05/19/jQuery/","text":"jQuery框架原理 ( function (window, undefined) { window.jQuery = window.$ = jQuery }(window); 1.通过观察,发现jQuery是一个闭包 2.为什么使用jQuery 2.1 防止和其他框架发生冲突 3.闭包变量函数外界是不能访问的,那么jQuery是如何让外界可以访问闭包中的变量? 3.1将内部的变量/函数绑定给window 4.jQuery的闭包为什么要给自己传递一个window参数? 4.1 为了方便压缩代码; 4.2 为了提升查找的效率; 5. 为什么闭包的形参要接收一个undefined? 5.1 为了方便压缩代码 5.2 在IE9以下的浏览器中的undefined的值都是可以修改的,所以为了保证jQuery中的undefined都是未被修改的; 6. 系统内部将一个jQuery变量赋值给了window.$ 注意: 通过new Dog创建对象 Dog在函数中如果返回的是基本数据类型,那么最终拿到的还是Dog对象 如果在Dog函数中如果返回的是对象类型,那么最终拿到的就是返回的那个对象类型; function Dog(){ // 通过new Dow()创建对象 // 在Dog函数中如果返回的是基本数据类型, 那么最终拿到的还是Dog对象 // 如果在Dog函数中如果返回的是对象类型, 那么最终拿到的就是返回的那个对象类型 return new Dog.prototype.init(); } Dog.prototype = { constructor: Dog, init: function(){ this.name = &apos;td&apos;; this.age = 35; }, say: function(){ console.log(&apos;say &apos;+this.name+&apos; &apos;+this.age); } } Dog.prototype.init.prototype = Dog.prototype; var d = new Dog(); // 找不到say方法, 因为say方法是定义在Dog.prototype中的 // 而d对象是通过init函数创建出来的, 只会去init.prototype中查找, 所以找不到 // 解决方案就是将init.prototype和Dog.prototype变为同一个prototype 接收的参数 1.传入&apos;&apos; null undefined NaN 0 false 返回一个空对象 this 2. 传入选择器 返回一个jQuery实例,将查找到的元素作为 的jQuery实例中 3. html片段 返回一个jQuery实例,创建代码片段对应的一级元素,作为返回一个jQuery实例中 4.数组 返回一个jQuery实例,会将数组中的每一个元素依次,作为返回一个jQuery实例中 5.伪数组 5.1 什么是伪数组? 伪数组是一个长得像数组的对象 伪数组必须满足两个条件 第一个条件:必须有length属性 第二个条件:必须有length-1 的那个属性 var obj= {0:&apos;name&apos;,1:&apos;age&apos;, length:2} 返回一个jQuery实例,会将伪数组中的每一个元素依次,作为返回一个jQuery实例中 6.对象 返回一个jQuery实例,直接把对象当做一个属性存储在jQuery实例中 7.DOM 返回一个jQuery实例,直接把DOM对象当做一个属性存储在jQuery实例中 8.基本数据类型 返回一个jQuery实例,会直接把基本数据类型当做一个属性存储在jQuery实例中 除了(&apos;&apos; null undefined NaN 0 false ) apply和call方法的作用: 都可以修改函数中的this apply和call方法的都可以给函数传参 apply格式: apply(对象, [参数列表]); call格式: call(对象, 参数1, 参数2, ...); 应用场景: apple适用于参数个数不确定的情况 call适用于参数个数确定情况 1.伪数组转真数组 /* 1.谁调用方法, 那么方法内部的this就是谁 2.[].push并不是调用push方法, 而是找到数组的push方法 类似于 window.test 3.push.apply(arr), 修改push内部的this为指定的对象 可以理解为就是利用指定对象调用push方法 4.push.apply(arr, obj), 将伪数组obj传递给了push方法 apply方法内部会自动取出伪数组的每一项传递个push方法 可以理解为依次将伪数组中的元素push到了指定的对象中 */ /* var obj = {0:&apos;name&apos;, 1:&apos;age&apos;, length: 2}; var arr = []; [].push.apply(arr, obj); console.log(arr); */ // 2.真数组转伪数组 var arr = [&apos;nj&apos;, &apos;16&apos;, &apos;man&apos;]; var obj = {}; [].push.apply(obj, arr); console.log(obj); window的length是用于统计当前界面上 iframe 个数,但是 如果是利用apply对伪数组进行处理在IE8中会有问题 如果是利用apply对帧数组进行处理在IE8中没有问题","tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://zhoujianfish.github.io/tags/jQuery/"}]},{"title":"Javascript定时器中的this指向","date":"2017-04-11T06:06:34.597Z","path":"2017/04/11/Javascript定时器中的this指向/","text":"使用js中的定时器（setInterval，setTimeout），很容易会遇到this指向的问题。直接上例子：var name = &apos;my name is window&apos;; var obj = { name: &apos;my name is obj&apos;, fn: function () { var timer = null; clearInterval(timer); timer = setInterval(function () { console.log(this.name); //my name is window }, 1000) } } 在这里，从this.name可以看出this的指向是window。 如果没有特殊指向，setInterval和setTimeout的回调函数中this的指向都是window。这是因为JS的定时器方法是定义在window下的。但是平时很多场景下，都需要修改this的指向。这里总结了几种：1、最常用的方法：在外部函数中将this存为一个变量，回调函数中使用该变量，而不是直接使用this。 var name = &apos;my name is window&apos;; var obj = { name: &apos;my name is obj&apos;, fn: function () { var that = this; var timer = null; clearInterval(timer); timer = setInterval(function () { console.log(that.name); //my name is obj }, 1000) } } 在fn中加了var that = this; 回调函数中使用that代替this即可。这种方法最常见，使用也最广泛。 2、使用bind()方法（bind()为ES5的标准，低版本IE下有兼容问题，可以引入es5-shim.js解决）bind()的作用类似call和apply，都是修改this指向。但是call和apply是修改this指向后函数会立即执行，而bind则是返回一个新的函数，它会创建一个与原来函数主体相同的新函数，新函数中的this指向传入的对象。 var name = &apos;my name is window&apos;; var obj = { name: &apos;my name is obj&apos;, fn: function () { var timer = null; clearInterval(timer); timer = setInterval(function () { console.log(this.name); //my name is obj }.bind(this), 1000) } } 在这里为什么不能用call和apply，是因为call和apply不是返回函数，而是立即执行函数，那么，就失去了定时器的作用。 3、使用es6的箭头函数：箭头函数的最大作用就是this指向。var name = &apos;my name is window&apos;; var obj = { name: &apos;my name is obj&apos;, fn: function () { var timer = null; clearInterval(timer); timer = setInterval(() =&gt; { console.log(this.name); //my name is obj }, 1000) } } 箭头函数没有自己的this，它的this继承自外部函数的作用域。所以，在该例中，定时器回调函数中的this，是继承了fn的this。当然箭头函数也有兼容问题，要是兼容低版本ie，需要使用babel编译，并且引入es5-shim.js才可以。","tags":[]},{"title":"DSS","date":"2017-04-09T15:01:33.000Z","path":"2017/04/09/DSS/","text":"fgfdgdfgfdgdfgfdgfdgfdg","tags":[{"name":"sd","slug":"sd","permalink":"https://zhoujianfish.github.io/tags/sd/"}]},{"title":"","date":"2017-03-20T10:06:51.802Z","path":"2017/03/20/js基础/","text":"####一.数组的认识 数组的定义:用来存储表示一堆变量的集合 数组的特点:1.数组是有序号的,从0开始 2.数组中的存储的变量类型可以是不同的类型 数组访问;数组可以通过数组名称[序号值]来访问,例如: arr[1]访问数组中的第二个元素 数组的长度的获取.数组名称.length 数组的循环,通过for循环,形式是:for(var i = 0;i &lt; 数组的长度; i ++){执行代码} 数组的基本应用;设置不同的行现实不同的颜色,设置全选不选以及反选；实现九宫格算法 拍他思想的认识:1.先设置所有的为一种属性2.然后设置自己的独立属性,覆盖原来的 this的认识:this一般在事件指令中,表示谁被触发了,就表示谁 拍他思想的应用,以及设置不同颜色的方法的认识 变量和属性以及方法和函数的区别:属性需要隶属于某一个对象,变量不需要,函数属于某一个对象就是方法 属性的扩展：可以给某个一个对象扩展属性，用来记录销毁中的值 tab栏切换 tab栏切换抽取 数组的基本方法:1-push(),在数组的后面添加一个元素返回数组的长度;2-pop():从数组的后面删除一个元素返回删除的元素;3-shift(),从数组的前面删除一个元素 ,4-unshift(),从数组的前面添加一个元素,5-contact连接两个元素,原来的数组不会发生改变,6.sort();数组转化成字符后排序,但是如果要按照数值排序,需要使用函数参数,函数参数会自动执行7.数组转化字符：join（）8.字符转化数组 ：split（） ####二.字符串的常用方法的认识 转化成字符方法的认识 1.使用连接符号+ 2.使用String方法 获取某一位置的字符以及unicode编码的认识: charCodeAt()；获取某一个位置的字符：charat(); 获取某一个字符的位置的方法的认识,indexof(),如果从后往前后去：lastindexof(),注意排序还是从左到右 获取一个字符的真正的占字节的方法的获取:一般如果是汉字那么他的unicode编码就是大于127,在0和127内是普通的字母数字。 转化大小写：转化大写：toUpperCase;转化小写：toLowerCase获取某一个字符串的位置{% codeblock lang:JavaScript %} var charString = 'my is abc dcf a'; var poiont = charString.indexOf('n'); console.log(poiont); // -1; {% endcodeblock %} indexOf:会获取传入的字符的位置,位置从左到右边,如果获取到第一个元素后,就会返回第一个获取元素的位置,如果没有对应的元素就会返回 -1; {% codeblock lang:JavaScript %} var charString = 'my is abc dcf a'; var newPoint = charString.lastIndexOf('a'); console.log(newPoint); {% endcodeblock %} lastIndexOf:从后往前找对应的元素,如果找到就会把对应的位置返回,但是注意位置排序还是从左到右顺序数;","tags":[]},{"title":"","date":"2017-03-18T11:44:45.077Z","path":"2017/03/18/Ajax/","text":"Ajax注意点:PHP是服务端开发语言,所以不能直接运行,需要在服务骑上运行 如何在服务器上运行: 将编写好的代码文件夹放到服务器对应的文件夹下 然后通过浏览器访问服务器对应的文件 然后通过浏览器选择需要执行的那个php文件 PHP中也有数组$arr = array(1,3,5); echo $arr[1]; print_r($arr); JS中有数组和字典var arr = [1, 3, 5]; var dict = {&quot;name&quot;:&quot;nj&quot;, &quot;age&quot;:&quot;18&quot;} PHP中也有数组和字典$arr = array(1, 3, 5); $dict = array(&quot;name&quot;=&gt;&quot;nj&quot;, &quot;age&quot;=&gt;&quot;18&quot;); 在PHP中要输出数组/字典需要使用print_r###遍历 $arr = array(1, 3, 5, 7, 9); for($i = 0; $i &lt; count($arr); $i++){ echo $arr[$i]; echo ““; } $arr = array(1, 3, 5, 7, 9); $index = 0; while ($index &lt; count($arr)){ echo $arr[$index]; echo &quot;&lt;br&gt;&quot;; $index++; } $arr = array(1, 3, 5, 7, 9); $dict = array(&quot;name&quot;=&gt;&quot;nj&quot;, &quot;age&quot;=&gt;&quot;18&quot;); foreach ($dict as $item) { echo $item; echo &quot;&lt;br&gt;&quot;; }","tags":[]},{"title":"Javascript的this用法","date":"2017-03-14T15:31:24.565Z","path":"2017/03/14/JavaScript/","text":"this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。比如，123function test()&#123; this.x = 1 &#125; 随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。下面分四种情况，详细讨论this的用法。情况一：纯粹的函数调用这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global。请看下面这段代码，它的运行结果是112345function test()&#123; this.x = 1; alert(this.x); &#125;test(); // 1 为了证明this就是全局对象，我对代码做一些改变：12345 var x = 1;function test()&#123; alert(this.x); &#125;test(); // 1 ### 运行结果还是1。再变一下：123456var x = 1;function test()&#123; this.x = 0; &#125;test();alert(x); //0 情况二：作为对象方法的调用函数还可以作为某个对象的方法调用，这时this就指这个上级对象。1234567function test()&#123; alert(this.x); &#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m(); // 1 情况三 作为构造函数调用所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。12345function test()&#123; this.x = 1; &#125;var o = new test();alert(o.x); // 1 运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变：123456var x = 2;function test()&#123; this.x = 1; &#125; var o = new test(); alert(x); //2 运行结果为2，表明全局变量x的值根本没变。情况四 apply调用apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。12345678 var x = 0;function test()&#123; alert(this.x); &#125;var o=&#123;&#125;;o.x = 1;o.m = test;o.m.apply(); //0 apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。如果把最后一行代码修改为12o.m.apply(o); //1 运行结果就变成了1，证明了这时this代表的是对象o。","tags":[]},{"title":"WEBPACK与GULP的区别及实例搭建","date":"2016-12-23T16:11:32.000Z","path":"2016/12/24/WEBPACK与GULP的区别及实例搭建/","text":"WEBPACK与GULP的区别及实例搭建 webpack是什么，提到这个概念，很多人可能立马说出来，模块化加载器兼打包工具，可以把各种资源都作为模块来使用和处理等等。 说到前端构建工具，不可避免的会提到gulp，到底webpack和gulp有什么区别呢？ 首先，其实webpack只是具有前端构建的功能而已，其实本质来说webpack是一种模块化的解决方案类似require.js一样，只不过通过插件实现了构建工具的一些功能，例如通过less－loader可以编译less为css并作为模块可以被调用。gulp是通过一系列插件将原本复杂繁琐的任务自动化，是一个纯粹的工具，并不能将你的css等非js资源模块化，但是webpack可以做到这些。总的来说，gulp是一个自动化任务的工具，所以你可以通过gulp来配置webpack的文件。 webpack的优点如下： 1. webpack 遵循commonJS 的形式，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。 2. 能被模块化的不仅仅是 JS ，所有的静态资源，例如css，图片等都能模块化，即以require的方式引入。 3. 开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等。 具体webpack如何使用可以通过一个很简单的demo项目来了解一下： 首先，在git上新建一个项目，同时全局安装webpack。（当然首先你要先安装了node） npm install webpack -g（可能需要sudo权限）。 安装之后可以通过webpack -v来查看当前版本。如果显示如下所示，说明安装成功Hash: 507b96dfc644d4199f75 Version: webpack 1.12.15 2, 通过packge.json配置依赖。通过npm install加载npm模块，接下来分析需要什么依赖什么插件， 1）webpack肯定要先行依赖的 2）本项目中存在js，html，less三部分，js不需要通过loader转换，所以需要less-loader，但基本的样式loader时肯定需要的所以要依赖三个插件，less-loader、css-loader、style-loader。如下所示：&quot;dependencies&quot;: { &quot;cnpm&quot;: &quot;^4.2.0&quot;, &quot;css-loader&quot;: &quot;^0.23.1&quot;,&quot;less-loader&quot;: &quot;^2.2.3&quot;, &quot;style-loader&quot;: &quot;^0.13.1&quot;, &quot;webpack&quot;: &quot;^1.12.15&quot; } 3，使用webpack.config.js进行配置管理，类似于gulpfile.js（遵循common.js的规范） 首先 要引入webpack var webpack = require(&apos;webpack&apos;); module.exports = { entry: &apos;./js/index&apos;,//页面入口文件配置 //文件输出配置 output: { path: __dirname,//当前文件package.json的路径 filename: &apos;/dist/index.js&apos;//打包之后输出的文件，即dist下的index.js }, module: { //加载器配置 loaders: [{ test: /\\.less$/, loader: &quot;style-loader!css-loader!less-loader&quot; }] } } 4，建相应文件夹及文件 1）html只需要加载打包之后的文件，即dist/下的indx.js即可，无需和原来一样分别加载js和css 1 &lt;head&gt; 2 &lt;meta charset=&quot;UTF-8&quot;&gt; 3 &lt;title&gt;index&lt;/title&gt; 4 &lt;script src=&quot;../dist/index.js&quot;&gt;&lt;/script&gt; 5 &lt;/head&gt; 2）index.less里就是简单的less语法的样式（以检查css是否生效）：body{ color: red; } 3)模块文件alerts.js里简单的返回字符串，以供测试。module.exports = &apos;this is webpack demo by 绝版猪&apos;; 4）入口文件里，引入less文件和模块alerts.js。require(&apos;../less/index.less&apos;);//引入less文件 var alerts = require(&apos;./alerts.js&apos;);//模块js文件 alert(&apos;so, it is so easy to use webpack&apos;); document.write(alerts); 5.执行npm run build查看是否成功，执行命令可以配置在gulp文件里也可以配置在package.json里。此处配置在package.json中： &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack&quot; }, 至此一个简单的基于webpack的demo搭建完成，此处只是个人的一点见解，希望抛砖引玉引来大神们的指教。","tags":[{"name":"webpack","slug":"webpack","permalink":"https://zhoujianfish.github.io/tags/webpack/"}]}]